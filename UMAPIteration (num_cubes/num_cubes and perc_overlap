import os
import re
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.preprocessing import LabelEncoder, StandardScaler
from sklearn.cluster import DBSCAN
import umap
import kmapper as km
from kmapper import Cover
import networkx as nx
from PIL import Image, ImageDraw, ImageFont
import matplotlib as mpl
import matplotlib.patches as mpatches

# =========================
# Load Data (CSV)
# =========================
df = pd.read_csv("DrugsFinal.csv")

# Guard columns
if "Disease" not in df.columns:
    df["Disease"] = "Unknown"
if "Drug Name" not in df.columns:
    df["Drug Name"] = [f"Drug_{i}" for i in range(len(df))]

# Numeric matrix with NA->mean, scale
numeric_df = df.select_dtypes(include=[np.number])
X = numeric_df.copy()
X = numeric_df.fillna(numeric_df.mean())
X_scaled = StandardScaler().fit_transform(X)

# Labels
diseases = df["Disease"].astype(str).values
drug_names = df["Drug Name"].astype(str).values
label_encoder = LabelEncoder()
disease_labels = label_encoder.fit_transform(diseases)


# UMAP Lens (2D)
lens = umap.UMAP(
    n_neighbors=5,
    min_dist=0.5,
    metric="cosine",     # change to "euclidean" if cosine not supported
    random_state=42
).fit_transform(X_scaled)

# Mapper Parameters
n_cubes_list = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]
perc_overlap_list = [0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5]
eps = 30
min_samples = 3


# Output Directory
output_dir = "mapper_images"
os.makedirs(output_dir, exist_ok=True)


# Disease color palette
unique_diseases = pd.Series(diseases).unique()
cmap = mpl.colormaps.get('tab20')  # nice categorical palette
disease_to_color = {d: cmap(i % 20) for i, d in enumerate(sorted(unique_diseases))}

# Kepler Mapper
mapper = km.KeplerMapper(verbose=0)

first_panel = True
for n_cubes in n_cubes_list:
    for perc_overlap in perc_overlap_list:
        # Build Mapper graph
        graph = mapper.map(
            lens,
            X_scaled,
            cover=Cover(n_cubes=n_cubes, perc_overlap=perc_overlap),
            clusterer=DBSCAN(eps=eps, min_samples=min_samples)
        )

        # Convert to NetworkX for plotting
        G = km.adapter.to_nx(graph)

        # Spring layout (deterministic)
        pos = nx.spring_layout(G, seed=42)

        # Node sizes/colors by membership and majority disease
        node_ids = list(G.nodes())
        node_sizes, node_colors = [], []

        for nid in node_ids:
            members = graph["nodes"][nid]  # list of sample indices
            size = 40 + 6 * len(members)   # scale node size by membership
            node_sizes.append(size)

            if len(members) == 0:
                node_colors.append("#cccccc")
            else:
                node_dz = pd.Series(diseases[members]).astype(str)
                majority = node_dz.value_counts().idxmax()
                node_colors.append(disease_to_color.get(majority, "#cccccc"))

        # Plot panel
        plt.figure(figsize=(10, 8))
        if len(node_ids) > 0:
            nx.draw_networkx_nodes(
                G, pos,
                node_size=node_sizes,
                node_color=node_colors,
                alpha=0.95,
                linewidths=0.5,
                edgecolors="black"
            )
        if len(G.edges()) > 0:
            nx.draw_networkx_edges(G, pos, alpha=0.35, width=0.8)
        plt.axis('off')

        # Legend only on the very first panel
        if first_panel:
            patches = [mpatches.Patch(color=disease_to_color[d], label=d) for d in sorted(unique_diseases)]
            plt.legend(handles=patches, title="Disease", loc="lower left",
                       bbox_to_anchor=(0, 1), frameon=False, ncol=3)
            first_panel = False

        name = f"c{n_cubes}_o{int(perc_overlap*100)}.png"
        plt.savefig(os.path.join(output_dir, name), dpi=300, bbox_inches='tight')
        plt.close()

print("Mapper images saved to:", output_dir)

# Stitch panels into labeled grid
folder = output_dir
output_file = "mapper_grid_custom_labels.png"

file_list = [f for f in os.listdir(folder) if f.endswith(".png")]
images = {}
pattern = re.compile(r"c(\d+)_o(\d+)\.png")
for fname in file_list:
    match = pattern.match(fname)
    if not match:
        continue
    nc = int(match.group(1))
    ov = int(match.group(2)) / 100
    img = Image.open(os.path.join(folder, fname))
    images[(nc, ov)] = img

if not images:
    raise RuntimeError("No images found to compose. Check earlier steps for errors.")

# Font (fallback if arial not available)
try:
    font = ImageFont.truetype("arial.ttf", size=100)
except IOError:
    font = ImageFont.load_default()

def text_bbox(text, fnt):
    try:
        return fnt.getbbox(text)
    except Exception:
        # Older PIL fallback
        return ImageDraw.Draw(Image.new("RGB", (1, 1))).textbbox((0, 0), text, font=fnt)

# Dimensions
sample_img = next(iter(images.values()))
img_w, img_h = sample_img.size

label_h = max(text_bbox(f"n_cubes = {n}, overlap = {o:.2f}", font)[3]
              for n in n_cubes_list for o in perc_overlap_list) + 5
cell_w = img_w
cell_h = img_h + label_h

# Axis margins
top_margin = 500
left_margin = 1200

# Canvas
grid_w = left_margin + cell_w * len(n_cubes_list)
grid_h = top_margin + cell_h * len(perc_overlap_list)
grid_img = Image.new("RGB", (grid_w, grid_h), "white")
draw = ImageDraw.Draw(grid_img)

# Paste cells with labels
for i, overlap in enumerate(perc_overlap_list):
    for j, n_cubes in enumerate(n_cubes_list):
        x = left_margin + j * cell_w
        y = top_margin + i * cell_h
        img = images.get((n_cubes, overlap))
        if img:
            grid_img.paste(img, (x, y))
            label = f"n_cubes = {n_cubes}, overlap = {overlap:.2f}"
            bbox = text_bbox(label, font)
            lw = bbox[2] - bbox[0]
            draw.text((x + (cell_w - lw) // 2, y + img_h + 10), label, fill="black", font=font)

# Top axis: n_cubes
for j, n in enumerate(n_cubes_list):
    label = str(n)
    bbox = text_bbox(label, font)
    lw = bbox[2] - bbox[0]
    lh = bbox[3] - bbox[1]
    draw.text((left_margin + j * cell_w + (cell_w - lw) // 2, (top_margin - lh) // 2),
              label, fill="black", font=font)

# Left axis: perc_overlap
for i, o in enumerate(perc_overlap_list):
    label = f"{o:.2f}"
    bbox = text_bbox(label, font)
    lw = bbox[2] - bbox[0]
    lh = bbox[3] - bbox[1]
    draw.text((left_margin - lw - 15, top_margin + i * cell_h + (img_h - lh) // 2),
              label, fill="black", font=font)

# Axis titles
title_font = font
title = "n_cubes"
tw = text_bbox(title, title_font)[2]
draw.text((left_margin + (grid_w - left_margin - tw) // 2, 10),
          title, fill="black", font=title_font)

title = "perc_overlap"
tb = text_bbox(title, title_font)
tw, th = tb[2], tb[3]
draw.text((10, top_margin + (grid_h - top_margin - th) // 2),
          title, fill="black", font=title_font)

grid_img.save(output_file)
print(f"Saved grid to {output_file}")

